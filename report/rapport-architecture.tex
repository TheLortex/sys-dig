\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{relsize}
\usepackage{dsfont}
\usepackage{array}
\usepackage[margin=1.0in]{geometry}

\title{Architecture du processeur}
\author{Pluvinage Lucas, Fehr Mathieu, Dang-nhu Hector, Voss Malachi}
\begin{document}

\maketitle

\section{Modèle de processeur}

Nous avons choisi de beaucoup nous inspirer des processeurs ARM, qui ont
l'avantage d'avoir un jeu d'instruction à la fois simple et complet, tout en
possédant une certaine efficacité grace aux conditionnement des instructions,
permettant de réduire le nombre de jump à effectuer dans les instructions
assembleurs.

\section{Mémoires et registres}

Le procésseur possède une unique RAM et une unique ROM. Au démarrage de la
simulation, la RAM est entièrement vide. La ROM contient le programme sous forme
d'opcodes, générés par du code assembleur.

Le processeur contient 16 registres addressés sur 4 bits. Le registre \%r00
pointe sur l'instruction actuelle à lire dans la ROM.

\section{Opcodes}

Une instruction assembleur est écrite sous 32 bits, et est structurée ainsi :

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
  \hline
  0-3  & 4 & 5 & 6 & 7-10 & 11 & 12-15 & 16-19 & 20-23 & 24-27 & 28-31 \\
  \hline
  COND &   & 1 & \multicolumn{8}{c|}{Opération sur la RAM} \\
  \hline
  COND &   & 0 & I & OPCODE & Set flag & Registre rd & Registre op1 & \multicolumn{3}{c|}{Opérande op2}  \\
  \hline
  COND &   & 0 & 1 & OPCODE & Set flag & Registre rd &Registre op1 & Shift & \multicolumn{2}{c|}{Constante} \\
  \hline
  COND &   & 0 & 0 & OPCODE & Set flag & Registre rd & Registre op1 & \multicolumn{2}{c|}{Shift} & r2  \\
  \hline
\end{tabular}

\subsection{Flags}

A chaque opération, si le booléen set flag est activé, alors les flags sont
recalculés :
  \begin{itemize}
  \item N : La dernière instruction renvoie un entier négatif
  \item Z : La dernière instruction renvoie zéro
  \item C : La dernière instruction fait un dépassement dans la représentation
    non signée
  \item V : La dernière instruction fait un dépassement dans la représentation
    signée
  \end{itemize}

  \subsection{Conditionnelles}

  Voici les codes des conditions d'executions des opérations:\\

\begin{tabular}{|c|c|c|c|}
  \hline
  Code & Nom & Condition sur les flags & Signification (pour CMP ou SUB)\\
  \hline
  0000 & EQ & Z & Égalité\\
  0001 & NEQ & $\bar{Z}$ & Non égalité\\
  0010 & CS/HS & C & Carry set\\
  0011 & CC/LO & $\bar{C}$ & Carry clear\\
  0100 & MI & N & Négatif \\
  0101 & PL & $\bar{N}$ & Positif ou nul \\
  0110 & VS & V & Overflow signé \\
  0111 & VC & $\bar{V}$ & Pas d'overflow signé \\
  1000 & HI & C and $\bar{Z}$ & Strictement plus grand non signé \\
  1001 & LS & $\bar{C}$ or Z & Plus petit non signé \\
  1010 & GE & N == V & Plus grand signé \\
  1011 & LT & N != V & Strictement plus petit signé\\
  1100 & GT & $\bar{Z}$ and (N == V) & Strictement plus grand signé \\
  1101 & LE & Z or (N != V) & Plus petit signé \\
  1111 & AL &  & Toujours exécuté \\
  \hline
\end{tabular}

\section{Instructions assembleur}

La syntaxe pour effectuer les opérations en assembleur suit la syntaxe spécifiée
sur les processeurs ARM.

\subsection{Opérations arithmétiques et booléennes}

Voici les opérations assembleur arithmétiques et booléennes :\\

\begin{tabular}{|c|c|c|}
  \hline
  Opcode & Nom assembleur & effet \\
  \hline
  0000 & ADD & R[rd] = op1 + op2\\
  0001 & ADC & R[rd] = op1 + op2 + c\\
  0010 & RSB & R[rd] = op2 - op1\\
  0011 & RSC & R[rd] = op2 - op1 + c - 1\\
  0100 & CMP & set les flags sur op1 - op2\\
  0101 & CMN & set les flags sur op1 + op2\\
  0110 & SUB & R[rd] = op1 - op2 \\
  0111 & SBC & R[rd] = op1 - op2 + c - 1\\
  1000 & AND & op1 and op2\\
  1001 & TST & set les flags sur op1 and op2\\
  1010 & ORR & op1 or op2\\
  1011 & BIC & op1 nand op2\\
  1100 & NOT & not op2\\
  1101 & MOV & op2\\
  1110 & EOR & op1 xor op2\\
  1111 & TEQ & set les flags sur op1 xor op2\\
  \hline
\end{tabular}

Où c représente le carry

\subsection{Accès à la mémoire}

Deux opérations sont possibles lors de l'accès à la mémoire :\\

\begin{tabular}{|c|c|c|}
  \hline
  Opcode & Nom assembleur & effet\\
  \hline
  0 & LDR & R[Rd] = mémoire à l'adresse op2\\
  1 & STR & mémoire à l'adresse op2 = R[Rd]\\
  \hline

\end{tabular}

\end{document}
